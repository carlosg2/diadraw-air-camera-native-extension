<?xml version="1.0" encoding="utf-8"?>

<!-- /** 
* Native camera extension example 
* @author Radoslava Leseva, diadraw.com
*/ -->

<s:View xmlns:fx="http://ns.adobe.com/mxml/2009" 
		xmlns:s="library://ns.adobe.com/flex/spark" 
		creationComplete="view_creationCompleteHandler(event)"
		resize="view_resizeHandler(event)">
	
	
	<fx:Script>
		<![CDATA[
			import com.diadraw.extensions.camera.NativeCameraExtension;
			import com.diadraw.extensions.camera.NativeCameraExtensionEvent;
			
			import flashx.textLayout.elements.BreakElement;
			
			import mx.events.FlexEvent;
			import mx.events.ResizeEvent;
			
			import spark.events.TrackBaseEvent;
			import spark.primitives.BitmapImage;
			
			
			protected function view_creationCompleteHandler(event:FlexEvent):void
			{
				m_cameraExt = new NativeCameraExtension();
				m_cameraExt.addEventListener( NativeCameraExtensionEvent.STATUS_EVENT, handleStatusEvent );
				
				m_usingFrontCamera = false;
				m_isVideoInProgress = false;
			}
			
			
			protected function view_resizeHandler( _event : ResizeEvent ):void
			{
				var isPortrait : Boolean = height > width;
				currentState = isPortrait ? S_PORTRAIT : S_LANDSCAPE;
				
				if ( null != m_log )
				{
					m_log.visible = isPortrait && ( m_log.text.length > 0 );
				}
			}

			
			private function toggleCameraPreview() : void
			{
				if ( m_isVideoInProgress )
				{
					m_btnVideoCamera.label = "Start Video Camera";
					m_btnVideoCamera.setStyle( "color", 0x000000 );
					
					m_cameraExt.stopVideoCamera();
				}
				else
				{
					m_btnVideoCamera.label = "Stop Video Camera";
					m_btnVideoCamera.setStyle( "color", 0xFF0000 );
					
					if ( m_cameraExt.startVideoCamera( RESOLUTION_PRESET, MIN_FRAMES_PER_SECOND, MAX_FRAMES_PER_SECOND, m_usingFrontCamera ) )
					{
						m_lastFrameIdx = int.MIN_VALUE;
						m_cameraExt.addEventListener( NativeCameraExtensionEvent.IMAGE_READY, handleImageReady );
					}
				}
				
				m_isVideoInProgress = !m_isVideoInProgress;
			}
			
			
			protected function btnVideoCamera_clickHandler( _event : MouseEvent ):void
			{
				toggleCameraPreview();
			}	
			
			
			protected function btnSwapCameras_clickHandler( _event : MouseEvent ) : void
			{
				if ( m_isVideoInProgress )
				{
					m_cameraExt.stopVideoCamera();
				
					m_usingFrontCamera = !m_usingFrontCamera;
					
					if ( !m_cameraExt.startVideoCamera( RESOLUTION_PRESET, MIN_FRAMES_PER_SECOND, MAX_FRAMES_PER_SECOND, m_usingFrontCamera ) )
					{
						addToLog( "Camera swap failed" );
						toggleCameraPreview();
					}
					
					btnSwapCameras.label = btnSwapCameraLabel;
				}
			}
			

			protected function btnAutoWhiteBalance_clickHandler( _event : MouseEvent ):void
			{
				m_whiteBalanceOptions.closeDropDown();	
				m_cameraExt.setWhiteBalanceMode( NativeCameraExtension.WhiteBalanceModeAutoWhiteBalance );
			}
			
			
			protected function btnLockWhiteBalance_clickHandler( _event : MouseEvent ):void
			{
				m_whiteBalanceOptions.closeDropDown();	
				m_cameraExt.setWhiteBalanceMode( NativeCameraExtension.WhiteBalanceModeLocked );
			}
			
	
			protected function btnLockFocus_clickHandler( _event : MouseEvent ):void
			{
				m_focusOptions.closeDropDown();	
				m_cameraExt.setFocusMode( NativeCameraExtension.FocusModeLocked );
			}
			
			
			protected function btnAutoFocus_clickHandler( _event : MouseEvent ):void
			{
				m_focusOptions.closeDropDown();				
				m_cameraExt.setFocusMode( NativeCameraExtension.FocusModeAutoFocus );
			}

			
			protected function btnLockExposure_clickHandler( _event : MouseEvent ):void
			{
				m_exposureOptions.closeDropDown();	
				m_cameraExt.setExposureMode( NativeCameraExtension.ExposureModeLocked );
			}

			
			protected function btnAutoExpose_clickHandler( _event : MouseEvent ):void
			{
				m_exposureOptions.closeDropDown();
				m_cameraExt.setExposureMode( NativeCameraExtension.ExposureModeContinuousAutoExposure );
			}
			
			
			protected function torchToggle_changeHandler( _event : Event ):void
			{
				m_cameraExt.setTorchMode( torchToggle.selected ? NativeCameraExtension.TorchModeOn : NativeCameraExtension.TorchModeOff );
			}
			
			
			protected function m_image_clickHandler( _event : MouseEvent ):void
			{
				var x : Number = _event.localX;
				var y : Number = _event.localY;
				
				m_image.graphics.clear();
				m_image.graphics.lineStyle( 2, 0x0000FF );
				m_image.graphics.drawRect( x - FOCUS_RECT_HALF_SIZE_PIX, y - FOCUS_RECT_HALF_SIZE_PIX, FOCUS_RECT_SIZE_PIX, FOCUS_RECT_SIZE_PIX );
				
				var m : Matrix = new Matrix();
				var w : Number = m_image.width;
				var h : Number = m_image.height;
				
				switch ( stage.orientation )
				{
					case StageOrientation.DEFAULT:
						{
							w = m_image.height;
							h = m_image.width;
							
							m.rotate( -90 * ( Math.PI / 180 ) );
							m.translate( 0, h );
						}
						break;
					
					case StageOrientation.UPSIDE_DOWN:
						{
							w = m_image.height;
							h = m_image.width;
	
							m.rotate( 90 * ( Math.PI / 180 ) );
							m.translate( w, 0 );
						}
						break;
					
					case StageOrientation.ROTATED_LEFT:
						{
							if ( !m_usingFrontCamera )
							{
								m.rotate( 180 * ( Math.PI / 180 ) );
								m.translate( w, h );
							}
						}
						break;
					
					case StageOrientation.ROTATED_RIGHT:
						{
							if ( m_usingFrontCamera )
							{
								m.rotate( 180 * ( Math.PI / 180 ) );
								m.translate( w, h );
							}
						}
						break;
					
					default:
						break;
				}
				
				var screenPoint : Point = new Point( _event.localX, _event.localY );
				var imgPoint : Point = m.transformPoint( screenPoint );
				
				var pointOfInterest : Point = new Point( imgPoint.x / w, imgPoint.y / h );

				m_cameraExt.setExposureMode( NativeCameraExtension.ExposureModeContinuousAutoExposure, pointOfInterest );
				m_cameraExt.setFocusMode( NativeCameraExtension.FocusModeContinuousAutoFocus, pointOfInterest );
			}
			
			
			protected function m_image_gestureRotateHandler( _event : TransformGestureEvent ):void
			{
				m_rotationDegrees += _event.rotation;
				m_cameraExt.setRotationAngle( -m_rotationDegrees );
			}
			
			
			protected function m_image_gesturePanHandler( _event : TransformGestureEvent ):void
			{
				m_cameraExt.setTranslationPoint( _event.offsetX, _event.offsetY );
			}

			
			private function handleImageReady( _event : NativeCameraExtensionEvent ) : void
			{
				m_lastFrameWidth = _event.frameWidth;
				m_lastFrameHeight = _event.frameHeight;
				
				m_byteArray = new ByteArray();
				
				var currentFrameIdx : Number = m_cameraExt.getFrameBuffer( m_byteArray, m_lastFrameIdx );
				
				if ( currentFrameIdx != m_lastFrameIdx )
				{
					// The byte array is set to RGBA, little endian on the native side, so make sure we read the same way:
					m_byteArray.endian = Endian.LITTLE_ENDIAN;
					displayFrame( m_byteArray );
					m_lastFrameIdx = currentFrameIdx;
				} 	
			}


			private function displayFrame( _byteArray : ByteArray ) : void
			{
				var bd : BitmapData = new BitmapData( m_lastFrameWidth, m_lastFrameHeight, true );
				
				var renderRect : Rectangle = new Rectangle( 0, 0, m_lastFrameWidth, m_lastFrameHeight );
				
				bd.setPixels( renderRect, _byteArray );
				
				var m : Matrix = new Matrix();
				var w : Number = bd.width;
				var h : Number = bd.height;
				
				switch ( stage.orientation )
				{
					case StageOrientation.DEFAULT:
						{
							w = bd.height;
							h = bd.width;
							
							m.rotate( 90 * ( Math.PI / 180 ) );
							m.translate( w, 0 );
						}
						break;
					
					case StageOrientation.UPSIDE_DOWN:
						{
							w = bd.height;
							h = bd.width;
							
							m.rotate( -90 * ( Math.PI / 180 ) );
							m.translate( 0, h );
						}
						break;
					
					case StageOrientation.ROTATED_LEFT:
						{
							if ( !m_usingFrontCamera )
							{
								m.rotate( 180 * ( Math.PI / 180 ) );
								m.translate( w, h );
							}
						}
						break;
					
					case StageOrientation.ROTATED_RIGHT:
					{
						if ( m_usingFrontCamera )
						{
							m.rotate( 180 * ( Math.PI / 180 ) );
							m.translate( w, h );
						}
					}
						break;
					
					default:
						break;
				}
				
				var orientedBd : BitmapData = new BitmapData( w, h, true );
				orientedBd.draw( bd, m );
				
				m_image.graphics.clear();
				m_image.source = orientedBd;
				
				m_byteArray = null;
			}
			
			
			private function handleStatusEvent( _event : NativeCameraExtensionEvent ) : void
			{
				addToLog( _event.message + " " + _event.data );
			}
			
			
			private function addToLog( _message : String ) : void
			{
				m_log.appendText( "\n" + _message );
				
				m_log.visible = m_log.text.length > 0;
			}
			
			
			private function get btnSwapCameraLabel() : String
			{
				return m_usingFrontCamera ? "Switch to back camera" : "Switch to front camera";
			}
			
			
			private var m_cameraExt : NativeCameraExtension;
			private var m_byteArray : ByteArray;
			private var m_lastFrameIdx : Number;
			private var m_lastFrameWidth : Number;
			private var m_lastFrameHeight : Number;
			private var m_rotationDegrees : Number = 0;
			
			[Bindable]
			private var m_usingFrontCamera : Boolean = false;
			
			[Bindable]
			private var m_isVideoInProgress : Boolean;
			
			private const FOCUS_RECT_SIZE_PIX : Number = 60;
			private const FOCUS_RECT_HALF_SIZE_PIX : Number = FOCUS_RECT_SIZE_PIX * 0.5;
			
			private const RESOLUTION_PRESET : String = NativeCameraExtension.PresetHigh; 
			
			private const MIN_FRAMES_PER_SECOND : Number = 15;
			private const MAX_FRAMES_PER_SECOND : Number = 15;
			
			private const S_PORTRAIT : String = "portrait";
			private const S_LANDSCAPE : String = "landscape";

		]]>
	</fx:Script>
	
	
	<fx:Declarations>
		<s:State name="portrait"/>
		<s:State name="landscape"/>
	</fx:Declarations>
	
	
	<s:titleContent>
		<s:HGroup gap="10" verticalAlign="middle">
			<s:CalloutButton id="m_exposureOptions" label="Exposure" 
							 horizontalPosition="end" verticalPosition="after">
				<s:calloutLayout>
					<s:VerticalLayout/>
				</s:calloutLayout>
				
				<s:Button id="btnLockExposure" 		width="100%" label="Lock" click="btnLockExposure_clickHandler(event)"/>
				<s:Button id="btnAutoExpose" 		width="100%" label="Auto-expose" click="btnAutoExpose_clickHandler(event)"/>
			</s:CalloutButton>
			
			<s:CalloutButton id="m_focusOptions" label="Focus" horizontalPosition="end"
							 verticalPosition="after">
				<s:calloutLayout>
					<s:VerticalLayout/>
				</s:calloutLayout>
				
				<s:Button id="btnLockFocus" 	width="100%" label="Lock" click="btnLockFocus_clickHandler(event)"/>
				<s:Button id="btnAutoFocus" 	width="100%" label="Auto-focus" click="btnAutoFocus_clickHandler(event)"/>
			</s:CalloutButton>
			
			
			
			<s:CalloutButton id="m_whiteBalanceOptions" label="Wh. Balance" horizontalPosition="end"
							 verticalPosition="after">
				<s:calloutLayout>
					<s:VerticalLayout/>
				</s:calloutLayout>
				
				<s:Button id="btnLockWhiteBalance" 	width="100%" label="Lock" click="btnLockWhiteBalance_clickHandler(event)"/>
				<s:Button id="btnAutoWhiteBalance" 	width="100%" label="Auto-white balance" click="btnAutoWhiteBalance_clickHandler(event)"/>
			</s:CalloutButton>
			
			<s:Button id="btnSwapCameras" label="{btnSwapCameraLabel}" click="btnSwapCameras_clickHandler(event)" enabled="{m_isVideoInProgress}"/>
			
		</s:HGroup>
	</s:titleContent>
	
	
	<s:Image id="m_image" 
			 width="100%" 
			 height="100%" 
			 scaleMode="zoom" 

			 horizontalAlign="center"
			 verticalAlign="middle"
			 click="m_image_clickHandler(event)" 
			 gestureRotate="m_image_gestureRotateHandler(event)"
			 gesturePan="m_image_gesturePanHandler(event)"/>	
	
	<s:VGroup id="imgGroup" bottom="10" left="10" right="10" height="50%" gap="10">
		
		<s:TextArea id="m_log" width="100%" height="100%" visible="false"/>
		<s:HGroup textAlign="left">
			<s:Label height="100%" text="Torch" verticalAlign="middle"/>
			<s:ToggleSwitch id="torchToggle" change="torchToggle_changeHandler(event)"/>
		</s:HGroup>
		<s:Button id="m_btnVideoCamera" width="100%" label="Start Video Camera"
				  click="btnVideoCamera_clickHandler(event)" />
	</s:VGroup>
	
</s:View>
